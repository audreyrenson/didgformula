---
title: "Simulation study for DID G-formula paper"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{basic-simulation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Setup

```{r setup}
library(didgformula)
library(tidyverse)
library(furrr)
plan(multisession, workers = parallel::detectCores())
set.seed(6669)
```

The simulation is based on the following structural model:
$$ U_0 \sim \text{Bernoulli}(0.5) $$
$$ L_t \sim \text{Bernoulli}(\text{logit}^{-1}[\gamma_{0t} + \gamma_{1t}A_{t-1}]) $$
$$ A_0 = 0$$
$$(A_t | A_{t-1} = 1) = 1$$
$$(A_t | A_{t-1} = 0) \sim \text{Bernoulli}(\text{logit}{-1}[\alpha_{0t} +\alpha_{1t}U_0 + \alpha_{2t}L_t])$$
$$Y_t \sim \text{Normal}(\beta_{0t} + \beta_{1t}A_t + \beta_{2t}L_t + \beta_3U_0, \sigma^2_t)$$

Conceptually, package all the parameters in the vector $\Beta = (\alpha, \gamma, \beta)$.
First we pick parameter values to be used in all simulations.

```{r generate_parameters}
Tt=5
Beta = generate_parameters(Tt=Tt, mu_Beta_Y = 2) 
Beta
```

Then generate 1000 datasets of size N=10,000 each, under parallel trends.

```{r generate_data}
N_obs=1e4
N_po = N_obs*100
nsims = 10
results_template = tibble(sim = 1:nsims,
                          data= replicate(nsims, 
                                          generate_data(N = N_obs, Tt = Tt, Beta = Beta),
                                          simplify = FALSE))
```

The datasets look like this:

```{r look_at_data}
head(results_template$data[[1]])
```


Estimate the true values of the focal estimands $E[Y_t(\bar a) - Y_{t-1}(\bar a)]$, $t=1,2,...,T$ by generating potential outcomes under $\bar A=\bar a=\bar 0$.

```{r generate_truth}
data_po  = generate_data(N                  = N_po, 
                         Tt                 = Tt,
                         Beta               = Beta, 
                         potential_outcomes = TRUE)


estimates_truth <- tibble(t=1:Tt, estimate = colMeans(  calc_ydiffs(data_po, Tt) ))
estimates_truth
```

## Estimation

`iptw_pipeline()`, `ice_pipeline()`, and `or_pipeline()` all return a tibble with columns `t` and `estimates`, the latter being estmates of $E[Y_t(\bar a) - Y_{t-1}(\bar a)]$ under the stated assumptions. For example

```{r iptw-example}
iptw_example <- iptw_pipeline(data = results_template$data[[1]],
                              rhs_formula = '~L{t}', Tt=Tt)
iptw_example
```

The formula interface receives time indicators in curly braces under the assumption that your data has columns `At`, `Lt`, `Yt` for `t=0,1,...,T`. Next we perform estimation on all the simulated datasets.


```{r iptw}
results_iptw <- results_template %>%
  mutate(estimates = future_map(data, iptw_pipeline, rhs_formula = '~L{t}', Tt=Tt))
```


```{r ice}
results_ice <- results_template %>%
  mutate(estimates = future_map(data, 
                                ice_pipeline, 
                                inside_formula = '~L{t}', 
                                outside_formula = '~L{k}', 
                                Tt=Tt))
```


```{r outcome_regression}

results_or <- results_template %>%
  mutate(estimates = future_map(data, 
                                or_pipeline, 
                                y_formula = '~L{t}',
                                l_formula = '~1',
                                Tt=Tt,
                                nreps=N_obs*100, #number of reps for each monte-carlo iteration
                                .options = furrr_options(seed=TRUE)))
```



## Viewing and evaluating the results

First let's look at histograms of deviations from the estimated 'truth'
```{r histograms}
results_histograms(results_or, estimates_truth)
results_histograms(results_iptw, estimates_truth)
results_histograms(results_ice, estimates_truth)
```

Then we can estimate the bias and variance
```{r bias-variance}
estimate_bias_variance(results_iptw, estimates_truth)
estimate_bias_variance(results_ice, estimates_truth)
estimate_bias_variance(results_or, estimates_truth)
```

and we can check for asymptotic normality using the coverage of a normality-assuming confidence interval based on the simulation variance.

```{r}
estimate_ci_coverage(results_iptw, estimates_truth, 0.95)
estimate_ci_coverage(results_ice, estimates_truth, 0.95)
estimate_ci_coverage(results_or, estimates_truth, 0.95)
```
