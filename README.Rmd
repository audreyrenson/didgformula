---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# didgformula

<!-- badges: start -->
<!-- badges: end -->

The R package `didgformula` implements inverse-probability weighted, iterated conditional, and outcome regression estimators for the difference-in-differences g-formula. 

## Installation

Only the development version is available so far. You can install it from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("audreyrenson/didgformula")
```

## Overview

Suppose we observe $N$ iid copies of $(L_t, A_t, Y_t)$ over periods $t=0,1,...,T$, where $Y_t$ is a continuous outcome, $A_t$ is a binary (time-varying) treatment, and $L_t$ is a binary (time-varying) covariate. Denote potential outcomes $Y_t(\bar a)$, as the outcome that would have occurred at time $t$ had treatment history $\bar a$ been received. Say we with to estimate the quantity

$$
E[Y_t(\bar a) - Y_{t-1}(\bar a)]
$$

Say we are willing to make the following assumptions:

1. SUTVA
$$
\bar A = \bar a \implies Y_t(\bar a) = Y_t
$$
2. Positivity
3. Parallel trends
4. Pre-identification

Under assumptions 1-4, the quantity of interest is identified as:

$$
E[Y_t(\bar a) - Y_{t-1}(\bar a)] = \sum_{\bar l}E[Y_t - Y_{t-1}|\bar L=\bar l, \bar A=\bar a] \prod_{k=0}^tP(L_k=l_k |\bar A_{k-1}=\bar a_{k-1}, \bar L_{k-1}=\bar l_{k-1})
$$
I.e., the difference in differences g-formula. We can estimate this population quantity using inverse weighting, iterated conditional outcome modeling, or by modeling the outcome and covariates. Each of these approaches is implemented in `didgformula`.

## Examples

### Continuous outcomes

First we simulate some data under the stated assumptions:

```{r simulate-continuous}
library(didgformula)

set.seed(10)

time_periods = 5
N_obs        = 1e4
parameters   = generate_parameters(Tt=time_periods)
df           = generate_data(N=N_obs, Tt=time_periods, Beta=parameters, ylink = 'rnorm_identity')

head(df)
```

We can calculate the true parameters by generating a large number of potential outcomes under the same data-generating mechanism:

```{r}
df_po = generate_data(N=N_obs*10, Tt=time_periods, Beta=parameters, ylink='rnorm_identity', potential_outcomes = TRUE)

truth = colMeans(calc_ydiffs(df_po, Tt=time_periods)) #calc_ydiffs simply takes Y_t-Y_{t-1} for t=1,...,T
truth
```

We can estimate this using IPTW:

```{r}
estimates_iptw = iptw_pipeline(data = df, rhs_formula = '~L{t}', Tt=time_periods)
estimates_iptw
```
ICE:
```{r}
estimates_ice = ice_pipeline(data = df, inside_formula = '~L{t}', outside_formula = '~L{k}', Tt=time_periods)
estimates_ice
```

Outcome regression:
```{r}
estimates_or = or_pipeline(data = df, y_formula = '~L{t}', l_formula = '~1', Tt=time_periods, nreps=N_obs) #usually nreps should be much larger but in this example it appears fine
estimates_or
```



